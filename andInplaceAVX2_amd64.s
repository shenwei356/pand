// Code generated by command: go run asm-AndInplaceAVX2.go -out andInplaceAVX2_amd64.s -stubs andInplaceAVX2.go. DO NOT EDIT.

#include "textflag.h"

// func andInplaceAVX2(x []byte, y []byte)
// Requires: AVX, AVX2
TEXT Â·andInplaceAVX2(SB), NOSPLIT|NOPTR, $0-48
	// pointer of x
	MOVQ x_base+0(FP), AX

	// length of x
	MOVQ x_len+8(FP), CX

	// pointer of y
	MOVQ y_base+24(FP), DX

	// --------------------------------------------
	// end address of x, will not change: p + n
	MOVQ AX, BX
	ADDQ CX, BX

	// end address for loop
	// n <= 8, jump to tail
	CMPQ CX, $0x00000008
	JLE  tail

	// n < 16, jump to loop8
	CMPQ CX, $0x00000010
	JL   loop8_start

	// n < 32, jump to loop16
	CMPQ CX, $0x00000020
	JL   loop16_start

	// --------------------------------------------
	// end address for loop32
	MOVQ BX, CX
	SUBQ $0x0000001f, CX

loop32:
	// compute x & y, and save value to x
	VMOVDQU (AX), Y0
	VPAND   (DX), Y0, Y0
	VMOVDQU Y0, (AX)

	// move pointer
	ADDQ $0x00000020, AX
	ADDQ $0x00000020, DX
	CMPQ AX, CX
	JL   loop32

	// n <= 8, jump to tail
	MOVQ BX, CX
	SUBQ AX, CX
	CMPQ CX, $0x00000008
	JLE  tail

	// n < 16, jump to loop8
	CMPQ CX, $0x00000010
	JL   loop8_start

	// --------------------------------------------
loop16_start:
	// end address for loop16
	MOVQ BX, CX
	SUBQ $0x0000000f, CX

loop16:
	// compute x & y, and save value to x
	VMOVDQU (AX), X0
	VPAND   (DX), X0, X0
	VMOVDQU X0, (AX)

	// move pointer
	ADDQ $0x00000010, AX
	ADDQ $0x00000010, DX
	CMPQ AX, CX
	JL   loop16

	// n <= 8, jump to tail
	MOVQ BX, CX
	SUBQ AX, CX
	CMPQ CX, $0x00000008
	JLE  tail

	// --------------------------------------------
loop8_start:
	// end address for loop8
	MOVQ BX, CX
	SUBQ $0x00000007, CX

loop8:
	// compute x & y, and save value to x
	MOVQ (AX), BX
	ANDQ (DX), BX
	MOVQ BX, (AX)

	// move pointer
	ADDQ $0x00000008, AX
	ADDQ $0x00000008, DX
	CMPQ AX, CX
	JL   loop8

	// --------------------------------------------
tail:
	// left elements (<=8)
	MOVQ (AX), BX
	ANDQ (DX), BX
	MOVQ BX, (AX)
	RET

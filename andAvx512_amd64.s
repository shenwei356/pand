// Code generated by command: go run asm-AndAvx512.go -out andAvx512_amd64.s -stubs andAvx512.go. DO NOT EDIT.

#include "textflag.h"

// func andAvx512(r []byte, x []byte, y []byte)
// Requires: AVX, AVX2
TEXT Â·andAvx512(SB), NOSPLIT|NOPTR, $0-72
	// pointer of r
	MOVQ r_base+0(FP), AX

	// pointer of x
	MOVQ x_base+24(FP), CX

	// length of x
	MOVQ x_len+32(FP), DX

	// pointer of y
	MOVQ y_base+48(FP), BX

	// --------------------------------------------
	// end address of x, will not change: p + n
	MOVQ CX, SI
	ADDQ DX, SI

	// end address for loop
	// n <= 8, jump to tail
	CMPQ DX, $0x00000008
	JLE  tail

	// n < 16, jump to loop8
	CMPQ DX, $0x00000010
	JL   loop8_start

	// n < 32, jump to loop16
	CMPQ DX, $0x00000020
	JL   loop16_start

	// n < 64, jump to loop32
	CMPQ DX, $0x00000040
	JL   loop32_start

	// --------------------------------------------
	// end address for loop64
	MOVQ SI, DX
	SUBQ $0x0000003f, DX

loop64:
	// compute x & y, and save value to x
	VMOVDQU64 (CX), Z0
	VPANDQ   (BX), Z0, Z0
	VMOVDQU64 Z0, (AX)
	
	// move pointer
	ADDQ $0x00000040, CX
	ADDQ $0x00000040, BX
	ADDQ $0x00000040, AX
	CMPQ CX, DX
	JL   loop64

	// n <= 8, jump to tail
	MOVQ SI, DX
	SUBQ CX, DX
	CMPQ DX, $0x00000008
	JLE  tail

	// n < 16, jump to loop8
	CMPQ DX, $0x00000010
	JL   loop8_start

	// n < 32, jump to loop16
	CMPQ DX, $0x00000020
	JL   loop16_start

	// --------------------------------------------
loop32_start:
	// end address for loop32
	MOVQ SI, DX
	SUBQ $0x0000001f, DX

loop32:
	// compute x & y, and save value to x
	VMOVDQU (CX), Y0
	VPAND   (BX), Y0, Y0
	VMOVDQU Y0, (AX)

	// move pointer
	ADDQ $0x00000020, CX
	ADDQ $0x00000020, BX
	ADDQ $0x00000020, AX
	CMPQ CX, DX
	JL   loop32

	// n <= 8, jump to tail
	MOVQ SI, DX
	SUBQ CX, DX
	CMPQ DX, $0x00000008
	JLE  tail

	// n < 16, jump to loop8
	CMPQ DX, $0x00000010
	JL   loop8_start

	// --------------------------------------------
loop16_start:
	// end address for loop16
	MOVQ SI, DX
	SUBQ $0x0000000f, DX

loop16:
	// compute x & y, and save value to x
	VMOVDQU (CX), X0
	VPAND   (BX), X0, X0
	VMOVDQU X0, (AX)

	// move pointer
	ADDQ $0x00000010, CX
	ADDQ $0x00000010, BX
	ADDQ $0x00000010, AX
	CMPQ CX, DX
	JL   loop16

	// n <= 8, jump to tail
	MOVQ SI, DX
	SUBQ CX, DX
	CMPQ DX, $0x00000008
	JLE  tail

	// --------------------------------------------
loop8_start:
	// end address for loop8
	MOVQ SI, DX
	SUBQ $0x00000007, DX

loop8:
	// compute x & y, and save value to x
	MOVQ (CX), SI
	ANDQ (BX), SI
	MOVQ SI, (AX)

	// move pointer
	ADDQ $0x00000008, CX
	ADDQ $0x00000008, BX
	ADDQ $0x00000008, AX
	CMPQ CX, DX
	JL   loop8

	// --------------------------------------------
tail:
	// left elements (<=8)
	MOVQ (CX), SI
	ANDQ (BX), SI
	MOVQ SI, (AX)
	RET

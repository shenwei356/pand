// Code generated by command: go run asm-AndInplaceSSE2.go -out andInplaceSSE2_amd64.s -stubs andInplaceSSE2.go. DO NOT EDIT.

#include "textflag.h"

// func andInplaceSSE2(x []byte, y []byte)
// Requires: AVX
TEXT Â·andInplaceSSE2(SB), NOSPLIT|NOPTR, $0-48
	// pointer of x
	MOVQ x_base+0(FP), AX

	// length of x
	MOVQ x_len+8(FP), CX

	// pointer of y
	MOVQ y_base+24(FP), DX

	// --------------------------------------------
	// end address of x, will not change: p + n
	MOVQ AX, BX
	ADDQ CX, BX

	// end address for loop
	// n < 8, jump to tail
	CMPQ CX, $0x00000008
	JL   tail

	// n < 16, jump to loop8
	CMPQ CX, $0x00000010
	JL   loop8_start

	// --------------------------------------------
	// end address for loop16
	MOVQ BX, CX
	SUBQ $0x0000000f, CX

loop16:
	// compute x & y, and save value to x
	VMOVDQU (AX), X0
	VPAND   (DX), X0, X0
	VMOVDQU X0, (AX)

	// move pointer
	ADDQ $0x00000010, AX
	ADDQ $0x00000010, DX
	CMPQ AX, CX
	JL   loop16

	// n < 8, jump to tail
	MOVQ BX, CX
	SUBQ AX, CX
	CMPQ CX, $0x00000008
	JL   tail

	// --------------------------------------------
loop8_start:
	// end address for loop8
	MOVQ BX, CX
	SUBQ $0x00000007, CX

loop8:
	// compute x & y, and save value to x
	MOVQ (AX), SI
	ANDQ (DX), SI
	MOVQ SI, (AX)

	// move pointer
	ADDQ $0x00000008, AX
	ADDQ $0x00000008, DX
	CMPQ AX, CX
	JL   loop8

	// --------------------------------------------
tail:
	// left elements (<8)
	CMPQ AX, BX
	JE   end
	MOVB (AX), CL
	ANDB (DX), CL
	MOVB CL, (AX)
	ADDQ $0x00000001, AX
	ADDQ $0x00000001, DX
	JMP  tail

end:
	RET
